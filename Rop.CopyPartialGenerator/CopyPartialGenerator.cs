using System.Collections.Concurrent;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Rop.CopyPartialGenerator
{
    [Generator]
    public class CopyPartialGenerator : ISourceGenerator
    {


        public void Initialize(GeneratorInitializationContext context)
        {
            //#if DEBUG
            //            if (!Debugger.IsAttached)
            //            {
            //                Debugger.Launch();
            //            }
            //#endif 
            context.RegisterForSyntaxNotifications(() => new PartialClassesToCopyReceiver());

        }

        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as PartialClassesToCopyReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, CopyClassToAugment classtoaugment)
        {
            var file = classtoaugment.ClassToAugment.FileName +".CopyClassTo_"+classtoaugment.NewClassName+".g.cs";
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for CopyPartialTo");
            sb.AppendLines(classtoaugment.NewHeader());
            sb.AppendLines(classtoaugment.NewBody());
            sb.AppendLines(classtoaugment.ClassToAugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }
        
        class PartialClassesToCopyReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<CopyClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<CopyClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                // Business logic to decide what we're interested in goes here
                if (syntaxNode is ClassDeclarationSyntax cds)
                {
                    var atts = cds.GetDecoratedManyWith("CopyPartialTo","CopyPartialAsImmutableRecord","CopyPartialAsEditableClass");
                    if (atts.Length==0) return;
                    foreach (var attributeSyntax in atts)
                    {
                        var ac = new CopyClassToAugment(cds,attributeSyntax);
                        if (ac.NewClassName != null) ClassesToAugment.Add(ac);
                    }
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<CopyClassToAugment>();
            }
        }
    }
}
